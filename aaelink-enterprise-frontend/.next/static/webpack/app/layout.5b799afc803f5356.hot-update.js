"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/offline-manager.ts":
/*!********************************!*\
  !*** ./lib/offline-manager.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   offlineManager: () => (/* binding */ offlineManager)\n/* harmony export */ });\n/* harmony import */ var _offline_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./offline-storage */ \"(app-pages-browser)/./lib/offline-storage.ts\");\n/**\n * AAELink Enterprise Offline Manager\n * Handles offline state, sync status, and conflict resolution\n * Version: 1.2.0\n */ \nclass OfflineManager {\n    setupEventListeners() {\n        if (false) {}\n        window.addEventListener('online', ()=>{\n            this.isOnline = true;\n            this.notifyListeners();\n            this.startSync();\n        });\n        window.addEventListener('offline', ()=>{\n            this.isOnline = false;\n            this.notifyListeners();\n        });\n        // Listen for visibility change to sync when tab becomes active\n        document.addEventListener('visibilitychange', ()=>{\n            if (!document.hidden && this.isOnline) {\n                this.startSync();\n            }\n        });\n    }\n    async loadLastSync() {\n        const lastSyncStr = localStorage.getItem('aaelink_last_sync');\n        if (lastSyncStr) {\n            this.lastSync = new Date(lastSyncStr);\n        }\n    }\n    async saveLastSync() {\n        this.lastSync = new Date();\n        localStorage.setItem('aaelink_last_sync', this.lastSync.toISOString());\n    }\n    // Public API\n    getStatus() {\n        return {\n            isOnline: this.isOnline,\n            lastSync: this.lastSync,\n            pendingSync: 0,\n            conflicts: 0,\n            storageUsed: 0,\n            storageTotal: 0 // Will be updated by storage info\n        };\n    }\n    getSyncProgress() {\n        return {\n            ...this.syncProgress\n        };\n    }\n    // Event listeners\n    addStatusListener(listener) {\n        this.listeners.add(listener);\n        return ()=>this.listeners.delete(listener);\n    }\n    addSyncProgressListener(listener) {\n        this.syncListeners.add(listener);\n        return ()=>this.syncListeners.delete(listener);\n    }\n    notifyListeners() {\n        const status = this.getStatus();\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(status);\n            } catch (error) {\n                console.error('Error in status listener:', error);\n            }\n        });\n    }\n    notifySyncListeners() {\n        this.syncListeners.forEach((listener)=>{\n            try {\n                listener(this.syncProgress);\n            } catch (error) {\n                console.error('Error in sync listener:', error);\n            }\n        });\n    }\n    // Sync operations\n    async startSync() {\n        if (!this.isOnline) {\n            console.log('[OfflineManager] Cannot sync - offline');\n            return;\n        }\n        console.log('[OfflineManager] Starting sync...');\n        try {\n            // Get sync queue count\n            const storageInfo = await _offline_storage__WEBPACK_IMPORTED_MODULE_0__.offlineStorage.getStorageInfo();\n            this.syncProgress = {\n                total: storageInfo.total,\n                completed: 0,\n                failed: 0,\n                current: 'Starting sync...'\n            };\n            this.notifySyncListeners();\n            // Process sync queue\n            await _offline_storage__WEBPACK_IMPORTED_MODULE_0__.offlineStorage.processSyncQueue();\n            // Update progress\n            this.syncProgress.completed = this.syncProgress.total;\n            this.syncProgress.current = 'Sync completed';\n            this.notifySyncListeners();\n            // Save last sync time\n            await this.saveLastSync();\n            console.log('[OfflineManager] Sync completed successfully');\n        } catch (error) {\n            console.error('[OfflineManager] Sync failed:', error);\n            this.syncProgress.failed++;\n            this.syncProgress.current = 'Sync failed';\n            this.notifySyncListeners();\n        }\n    }\n    async forceSync() {\n        console.log('[OfflineManager] Force sync requested');\n        await this.startSync();\n    }\n    // Conflict resolution\n    async detectConflicts() {\n        // This would typically check for conflicts between local and server data\n        // For now, return empty array as conflicts are handled during sync\n        return [];\n    }\n    async resolveConflict(conflictId, resolution) {\n        await _offline_storage__WEBPACK_IMPORTED_MODULE_0__.offlineStorage.resolveConflict(conflictId, resolution);\n    }\n    // Storage management\n    async getStorageInfo() {\n        const info = await _offline_storage__WEBPACK_IMPORTED_MODULE_0__.offlineStorage.getStorageInfo();\n        // Estimate storage usage (rough calculation)\n        const estimatedSize = info.total * 1024; // Assume 1KB per item average\n        const totalStorage = 50 * 1024 * 1024; // 50MB limit\n        return {\n            used: estimatedSize,\n            total: totalStorage,\n            byType: info.byType\n        };\n    }\n    async clearOfflineData() {\n        await _offline_storage__WEBPACK_IMPORTED_MODULE_0__.offlineStorage.clearAllData();\n        this.lastSync = null;\n        localStorage.removeItem('aaelink_last_sync');\n        this.notifyListeners();\n    }\n    // Utility methods\n    isDataStale() {\n        let maxAgeMinutes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n        if (!this.lastSync) return true;\n        const now = new Date();\n        const diffMinutes = (now.getTime() - this.lastSync.getTime()) / (1000 * 60);\n        return diffMinutes > maxAgeMinutes;\n    }\n    async getOfflineCapabilities() {\n        return {\n            canWorkOffline: true,\n            features: [\n                'View cached messages',\n                'Compose new messages',\n                'Access uploaded files',\n                'View calendar events',\n                'Search local data',\n                'User profile management'\n            ],\n            limitations: [\n                'Real-time updates disabled',\n                'File uploads queued for sync',\n                'New user registration disabled',\n                'Admin functions limited'\n            ]\n        };\n    }\n    // Background sync registration\n    async registerBackgroundSync() {\n        if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n            try {\n                const registration = await navigator.serviceWorker.ready;\n                await registration.sync.register('offline-messages');\n                await registration.sync.register('offline-files');\n                await registration.sync.register('offline-events');\n                console.log('[OfflineManager] Background sync registered');\n            } catch (error) {\n                console.error('[OfflineManager] Failed to register background sync:', error);\n            }\n        }\n    }\n    // Push notification setup\n    async requestNotificationPermission() {\n        if (!('Notification' in window)) {\n            console.log('[OfflineManager] Notifications not supported');\n            return false;\n        }\n        if (Notification.permission === 'granted') {\n            return true;\n        }\n        if (Notification.permission === 'denied') {\n            console.log('[OfflineManager] Notifications denied');\n            return false;\n        }\n        const permission = await Notification.requestPermission();\n        return permission === 'granted';\n    }\n    // Health check\n    async healthCheck() {\n        const issues = [];\n        const recommendations = [];\n        // Check online status\n        if (!this.isOnline) {\n            issues.push('Currently offline');\n            recommendations.push('Connect to internet for full functionality');\n        }\n        // Check storage\n        const storageInfo = await this.getStorageInfo();\n        const usagePercent = storageInfo.used / storageInfo.total * 100;\n        if (usagePercent > 90) {\n            issues.push('Storage nearly full');\n            recommendations.push('Clear offline data or increase storage limit');\n        }\n        // Check last sync\n        if (this.isDataStale(30)) {\n            issues.push('Data may be stale');\n            recommendations.push('Sync with server when online');\n        }\n        // Check service worker\n        if (!('serviceWorker' in navigator)) {\n            issues.push('Service worker not supported');\n            recommendations.push('Use a modern browser for offline features');\n        }\n        let status;\n        if (issues.length === 0) {\n            status = 'healthy';\n        } else if (issues.length <= 2) {\n            status = 'degraded';\n        } else {\n            status = 'unhealthy';\n        }\n        return {\n            status,\n            issues,\n            recommendations\n        };\n    }\n    constructor(){\n        this.isOnline =  true ? navigator.onLine : 0;\n        this.lastSync = null;\n        this.syncProgress = {\n            total: 0,\n            completed: 0,\n            failed: 0,\n            current: null\n        };\n        this.listeners = new Set();\n        this.syncListeners = new Set();\n        this.setupEventListeners();\n        this.loadLastSync();\n    }\n}\n// Export singleton instance\nconst offlineManager = new OfflineManager();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (offlineManager);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9vZmZsaW5lLW1hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUVrRDtBQWtCbkQsTUFBTUM7SUFpQklDLHNCQUE0QjtRQUNsQyxJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUUxQ0MsT0FBT0MsZ0JBQWdCLENBQUMsVUFBVTtZQUNoQyxJQUFJLENBQUNDLFFBQVEsR0FBRztZQUNoQixJQUFJLENBQUNDLGVBQWU7WUFDcEIsSUFBSSxDQUFDQyxTQUFTO1FBQ2hCO1FBRUFKLE9BQU9DLGdCQUFnQixDQUFDLFdBQVc7WUFDakMsSUFBSSxDQUFDQyxRQUFRLEdBQUc7WUFDaEIsSUFBSSxDQUFDQyxlQUFlO1FBQ3RCO1FBRUEsK0RBQStEO1FBQy9ERSxTQUFTSixnQkFBZ0IsQ0FBQyxvQkFBb0I7WUFDNUMsSUFBSSxDQUFDSSxTQUFTQyxNQUFNLElBQUksSUFBSSxDQUFDSixRQUFRLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQ0UsU0FBUztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSxNQUFjRyxlQUE4QjtRQUMxQyxNQUFNQyxjQUFjQyxhQUFhQyxPQUFPLENBQUM7UUFDekMsSUFBSUYsYUFBYTtZQUNmLElBQUksQ0FBQ0csUUFBUSxHQUFHLElBQUlDLEtBQUtKO1FBQzNCO0lBQ0Y7SUFFQSxNQUFjSyxlQUE4QjtRQUMxQyxJQUFJLENBQUNGLFFBQVEsR0FBRyxJQUFJQztRQUNwQkgsYUFBYUssT0FBTyxDQUFDLHFCQUFxQixJQUFJLENBQUNILFFBQVEsQ0FBQ0ksV0FBVztJQUNyRTtJQUVBLGFBQWE7SUFDYkMsWUFBMkI7UUFDekIsT0FBTztZQUNMZCxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QlMsVUFBVSxJQUFJLENBQUNBLFFBQVE7WUFDdkJNLGFBQWE7WUFDYkMsV0FBVztZQUNYQyxhQUFhO1lBQ2JDLGNBQWMsRUFBRSxrQ0FBa0M7UUFDcEQ7SUFDRjtJQUVBQyxrQkFBZ0M7UUFDOUIsT0FBTztZQUFF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Q3ZCckQsU0FBUztRQUNYLE9BQU8sSUFBSWlELE9BQU9JLE1BQU0sSUFBSSxHQUFHO1lBQzdCckQsU0FBUztRQUNYLE9BQU87WUFDTEEsU0FBUztRQUNYO1FBRUEsT0FBTztZQUFFQTtZQUFRaUQ7WUFBUUM7UUFBZ0I7SUFDM0M7SUF4UkEsYUFBYzthQVhOOUUsV0FBVyxLQUE2QixHQUFHZ0UsVUFBVWtCLE1BQU0sR0FBRyxDQUFJO2FBQ2xFekUsV0FBd0I7YUFDeEJXLGVBQTZCO1lBQ25DZ0IsT0FBTztZQUNQQyxXQUFXO1lBQ1hDLFFBQVE7WUFDUkMsU0FBUztRQUNYO2FBQ1FoQixZQUFrRCxJQUFJNEQ7YUFDdER4RCxnQkFBdUQsSUFBSXdEO1FBR2pFLElBQUksQ0FBQ3RGLG1CQUFtQjtRQUN4QixJQUFJLENBQUNRLFlBQVk7SUFDbkI7QUFzUkY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTStFLGlCQUFpQixJQUFJeEYsaUJBQWlCO0FBQ25ELGlFQUFld0YsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2Q3eTFjZS9BQUVMaW5rLW5ldy9hYWVsaW5rLWVudGVycHJpc2UtZnJvbnRlbmQvbGliL29mZmxpbmUtbWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFBRUxpbmsgRW50ZXJwcmlzZSBPZmZsaW5lIE1hbmFnZXJcbiAqIEhhbmRsZXMgb2ZmbGluZSBzdGF0ZSwgc3luYyBzdGF0dXMsIGFuZCBjb25mbGljdCByZXNvbHV0aW9uXG4gKiBWZXJzaW9uOiAxLjIuMFxuICovXG5cbmltcG9ydCB7IG9mZmxpbmVTdG9yYWdlIH0gZnJvbSAnLi9vZmZsaW5lLXN0b3JhZ2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9mZmxpbmVTdGF0dXMge1xuICBpc09ubGluZTogYm9vbGVhbjtcbiAgbGFzdFN5bmM6IERhdGUgfCBudWxsO1xuICBwZW5kaW5nU3luYzogbnVtYmVyO1xuICBjb25mbGljdHM6IG51bWJlcjtcbiAgc3RvcmFnZVVzZWQ6IG51bWJlcjtcbiAgc3RvcmFnZVRvdGFsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3luY1Byb2dyZXNzIHtcbiAgdG90YWw6IG51bWJlcjtcbiAgY29tcGxldGVkOiBudW1iZXI7XG4gIGZhaWxlZDogbnVtYmVyO1xuICBjdXJyZW50OiBzdHJpbmcgfCBudWxsO1xufVxuXG5jbGFzcyBPZmZsaW5lTWFuYWdlciB7XG4gIHByaXZhdGUgaXNPbmxpbmUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci5vbkxpbmUgOiB0cnVlO1xuICBwcml2YXRlIGxhc3RTeW5jOiBEYXRlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3luY1Byb2dyZXNzOiBTeW5jUHJvZ3Jlc3MgPSB7XG4gICAgdG90YWw6IDAsXG4gICAgY29tcGxldGVkOiAwLFxuICAgIGZhaWxlZDogMCxcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8KHN0YXR1czogT2ZmbGluZVN0YXR1cykgPT4gdm9pZD4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgc3luY0xpc3RlbmVyczogU2V0PChwcm9ncmVzczogU3luY1Byb2dyZXNzKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmxvYWRMYXN0U3luYygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzT25saW5lID0gdHJ1ZTtcbiAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnN0YXJ0U3luYygpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzT25saW5lID0gZmFsc2U7XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIGZvciB2aXNpYmlsaXR5IGNoYW5nZSB0byBzeW5jIHdoZW4gdGFiIGJlY29tZXMgYWN0aXZlXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIHRoaXMuaXNPbmxpbmUpIHtcbiAgICAgICAgdGhpcy5zdGFydFN5bmMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZExhc3RTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGxhc3RTeW5jU3RyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FhZWxpbmtfbGFzdF9zeW5jJyk7XG4gICAgaWYgKGxhc3RTeW5jU3RyKSB7XG4gICAgICB0aGlzLmxhc3RTeW5jID0gbmV3IERhdGUobGFzdFN5bmNTdHIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZUxhc3RTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubGFzdFN5bmMgPSBuZXcgRGF0ZSgpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhYWVsaW5rX2xhc3Rfc3luYycsIHRoaXMubGFzdFN5bmMudG9JU09TdHJpbmcoKSk7XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJXG4gIGdldFN0YXR1cygpOiBPZmZsaW5lU3RhdHVzIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNPbmxpbmU6IHRoaXMuaXNPbmxpbmUsXG4gICAgICBsYXN0U3luYzogdGhpcy5sYXN0U3luYyxcbiAgICAgIHBlbmRpbmdTeW5jOiAwLCAvLyBXaWxsIGJlIHVwZGF0ZWQgYnkgc3luYyBwcm9jZXNzXG4gICAgICBjb25mbGljdHM6IDAsIC8vIFdpbGwgYmUgdXBkYXRlZCBieSBjb25mbGljdCBkZXRlY3Rpb25cbiAgICAgIHN0b3JhZ2VVc2VkOiAwLCAvLyBXaWxsIGJlIHVwZGF0ZWQgYnkgc3RvcmFnZSBpbmZvXG4gICAgICBzdG9yYWdlVG90YWw6IDAgLy8gV2lsbCBiZSB1cGRhdGVkIGJ5IHN0b3JhZ2UgaW5mb1xuICAgIH07XG4gIH1cblxuICBnZXRTeW5jUHJvZ3Jlc3MoKTogU3luY1Byb2dyZXNzIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnN5bmNQcm9ncmVzcyB9O1xuICB9XG5cbiAgLy8gRXZlbnQgbGlzdGVuZXJzXG4gIGFkZFN0YXR1c0xpc3RlbmVyKGxpc3RlbmVyOiAoc3RhdHVzOiBPZmZsaW5lU3RhdHVzKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGFkZFN5bmNQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyOiAocHJvZ3Jlc3M6IFN5bmNQcm9ncmVzcykgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICAgIHRoaXMuc3luY0xpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnN5bmNMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2V0U3RhdHVzKCk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcihzdGF0dXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc3RhdHVzIGxpc3RlbmVyOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5U3luY0xpc3RlbmVycygpOiB2b2lkIHtcbiAgICB0aGlzLnN5bmNMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcih0aGlzLnN5bmNQcm9ncmVzcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzeW5jIGxpc3RlbmVyOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN5bmMgb3BlcmF0aW9uc1xuICBhc3luYyBzdGFydFN5bmMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmlzT25saW5lKSB7XG4gICAgICBjb25zb2xlLmxvZygnW09mZmxpbmVNYW5hZ2VyXSBDYW5ub3Qgc3luYyAtIG9mZmxpbmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW09mZmxpbmVNYW5hZ2VyXSBTdGFydGluZyBzeW5jLi4uJyk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IHN5bmMgcXVldWUgY291bnRcbiAgICAgIGNvbnN0IHN0b3JhZ2VJbmZvID0gYXdhaXQgb2ZmbGluZVN0b3JhZ2UuZ2V0U3RvcmFnZUluZm8oKTtcbiAgICAgIHRoaXMuc3luY1Byb2dyZXNzID0ge1xuICAgICAgICB0b3RhbDogc3RvcmFnZUluZm8udG90YWwsXG4gICAgICAgIGNvbXBsZXRlZDogMCxcbiAgICAgICAgZmFpbGVkOiAwLFxuICAgICAgICBjdXJyZW50OiAnU3RhcnRpbmcgc3luYy4uLidcbiAgICAgIH07XG4gICAgICB0aGlzLm5vdGlmeVN5bmNMaXN0ZW5lcnMoKTtcblxuICAgICAgLy8gUHJvY2VzcyBzeW5jIHF1ZXVlXG4gICAgICBhd2FpdCBvZmZsaW5lU3RvcmFnZS5wcm9jZXNzU3luY1F1ZXVlKCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICAgICAgdGhpcy5zeW5jUHJvZ3Jlc3MuY29tcGxldGVkID0gdGhpcy5zeW5jUHJvZ3Jlc3MudG90YWw7XG4gICAgICB0aGlzLnN5bmNQcm9ncmVzcy5jdXJyZW50ID0gJ1N5bmMgY29tcGxldGVkJztcbiAgICAgIHRoaXMubm90aWZ5U3luY0xpc3RlbmVycygpO1xuXG4gICAgICAvLyBTYXZlIGxhc3Qgc3luYyB0aW1lXG4gICAgICBhd2FpdCB0aGlzLnNhdmVMYXN0U3luYygpO1xuXG4gICAgICBjb25zb2xlLmxvZygnW09mZmxpbmVNYW5hZ2VyXSBTeW5jIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW09mZmxpbmVNYW5hZ2VyXSBTeW5jIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aGlzLnN5bmNQcm9ncmVzcy5mYWlsZWQrKztcbiAgICAgIHRoaXMuc3luY1Byb2dyZXNzLmN1cnJlbnQgPSAnU3luYyBmYWlsZWQnO1xuICAgICAgdGhpcy5ub3RpZnlTeW5jTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZm9yY2VTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKCdbT2ZmbGluZU1hbmFnZXJdIEZvcmNlIHN5bmMgcmVxdWVzdGVkJyk7XG4gICAgYXdhaXQgdGhpcy5zdGFydFN5bmMoKTtcbiAgfVxuXG4gIC8vIENvbmZsaWN0IHJlc29sdXRpb25cbiAgYXN5bmMgZGV0ZWN0Q29uZmxpY3RzKCk6IFByb21pc2U8YW55W10+IHtcbiAgICAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBjaGVjayBmb3IgY29uZmxpY3RzIGJldHdlZW4gbG9jYWwgYW5kIHNlcnZlciBkYXRhXG4gICAgLy8gRm9yIG5vdywgcmV0dXJuIGVtcHR5IGFycmF5IGFzIGNvbmZsaWN0cyBhcmUgaGFuZGxlZCBkdXJpbmcgc3luY1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGFzeW5jIHJlc29sdmVDb25mbGljdChjb25mbGljdElkOiBzdHJpbmcsIHJlc29sdXRpb246ICdsb2NhbCcgfCAnc2VydmVyJyB8ICdtZXJnZScpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBvZmZsaW5lU3RvcmFnZS5yZXNvbHZlQ29uZmxpY3QoY29uZmxpY3RJZCwgcmVzb2x1dGlvbik7XG4gIH1cblxuICAvLyBTdG9yYWdlIG1hbmFnZW1lbnRcbiAgYXN5bmMgZ2V0U3RvcmFnZUluZm8oKTogUHJvbWlzZTx7IHVzZWQ6IG51bWJlcjsgdG90YWw6IG51bWJlcjsgYnlUeXBlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IH0+IHtcbiAgICBjb25zdCBpbmZvID0gYXdhaXQgb2ZmbGluZVN0b3JhZ2UuZ2V0U3RvcmFnZUluZm8oKTtcblxuICAgIC8vIEVzdGltYXRlIHN0b3JhZ2UgdXNhZ2UgKHJvdWdoIGNhbGN1bGF0aW9uKVxuICAgIGNvbnN0IGVzdGltYXRlZFNpemUgPSBpbmZvLnRvdGFsICogMTAyNDsgLy8gQXNzdW1lIDFLQiBwZXIgaXRlbSBhdmVyYWdlXG4gICAgY29uc3QgdG90YWxTdG9yYWdlID0gNTAgKiAxMDI0ICogMTAyNDsgLy8gNTBNQiBsaW1pdFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZWQ6IGVzdGltYXRlZFNpemUsXG4gICAgICB0b3RhbDogdG90YWxTdG9yYWdlLFxuICAgICAgYnlUeXBlOiBpbmZvLmJ5VHlwZVxuICAgIH07XG4gIH1cblxuICBhc3luYyBjbGVhck9mZmxpbmVEYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IG9mZmxpbmVTdG9yYWdlLmNsZWFyQWxsRGF0YSgpO1xuICAgIHRoaXMubGFzdFN5bmMgPSBudWxsO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhYWVsaW5rX2xhc3Rfc3luYycpO1xuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgaXNEYXRhU3RhbGUobWF4QWdlTWludXRlczogbnVtYmVyID0gNSk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5sYXN0U3luYykgcmV0dXJuIHRydWU7XG5cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGRpZmZNaW51dGVzID0gKG5vdy5nZXRUaW1lKCkgLSB0aGlzLmxhc3RTeW5jLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKTtcblxuICAgIHJldHVybiBkaWZmTWludXRlcyA+IG1heEFnZU1pbnV0ZXM7XG4gIH1cblxuICBhc3luYyBnZXRPZmZsaW5lQ2FwYWJpbGl0aWVzKCk6IFByb21pc2U8e1xuICAgIGNhbldvcmtPZmZsaW5lOiBib29sZWFuO1xuICAgIGZlYXR1cmVzOiBzdHJpbmdbXTtcbiAgICBsaW1pdGF0aW9uczogc3RyaW5nW107XG4gIH0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FuV29ya09mZmxpbmU6IHRydWUsXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAnVmlldyBjYWNoZWQgbWVzc2FnZXMnLFxuICAgICAgICAnQ29tcG9zZSBuZXcgbWVzc2FnZXMnLFxuICAgICAgICAnQWNjZXNzIHVwbG9hZGVkIGZpbGVzJyxcbiAgICAgICAgJ1ZpZXcgY2FsZW5kYXIgZXZlbnRzJyxcbiAgICAgICAgJ1NlYXJjaCBsb2NhbCBkYXRhJyxcbiAgICAgICAgJ1VzZXIgcHJvZmlsZSBtYW5hZ2VtZW50J1xuICAgICAgXSxcbiAgICAgIGxpbWl0YXRpb25zOiBbXG4gICAgICAgICdSZWFsLXRpbWUgdXBkYXRlcyBkaXNhYmxlZCcsXG4gICAgICAgICdGaWxlIHVwbG9hZHMgcXVldWVkIGZvciBzeW5jJyxcbiAgICAgICAgJ05ldyB1c2VyIHJlZ2lzdHJhdGlvbiBkaXNhYmxlZCcsXG4gICAgICAgICdBZG1pbiBmdW5jdGlvbnMgbGltaXRlZCdcbiAgICAgIF1cbiAgICB9O1xuICB9XG5cbiAgLy8gQmFja2dyb3VuZCBzeW5jIHJlZ2lzdHJhdGlvblxuICBhc3luYyByZWdpc3RlckJhY2tncm91bmRTeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yICYmICdzeW5jJyBpbiB3aW5kb3cuU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbi5wcm90b3R5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdHJhdGlvbiA9IGF3YWl0IG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLnJlYWR5O1xuICAgICAgICBhd2FpdCByZWdpc3RyYXRpb24uc3luYy5yZWdpc3Rlcignb2ZmbGluZS1tZXNzYWdlcycpO1xuICAgICAgICBhd2FpdCByZWdpc3RyYXRpb24uc3luYy5yZWdpc3Rlcignb2ZmbGluZS1maWxlcycpO1xuICAgICAgICBhd2FpdCByZWdpc3RyYXRpb24uc3luYy5yZWdpc3Rlcignb2ZmbGluZS1ldmVudHMnKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tPZmZsaW5lTWFuYWdlcl0gQmFja2dyb3VuZCBzeW5jIHJlZ2lzdGVyZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tPZmZsaW5lTWFuYWdlcl0gRmFpbGVkIHRvIHJlZ2lzdGVyIGJhY2tncm91bmQgc3luYzonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBub3RpZmljYXRpb24gc2V0dXBcbiAgYXN5bmMgcmVxdWVzdE5vdGlmaWNhdGlvblBlcm1pc3Npb24oKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCEoJ05vdGlmaWNhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgY29uc29sZS5sb2coJ1tPZmZsaW5lTWFuYWdlcl0gTm90aWZpY2F0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZ3JhbnRlZCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2RlbmllZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbT2ZmbGluZU1hbmFnZXJdIE5vdGlmaWNhdGlvbnMgZGVuaWVkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGVybWlzc2lvbiA9IGF3YWl0IE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbigpO1xuICAgIHJldHVybiBwZXJtaXNzaW9uID09PSAnZ3JhbnRlZCc7XG4gIH1cblxuICAvLyBIZWFsdGggY2hlY2tcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7XG4gICAgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XG4gICAgaXNzdWVzOiBzdHJpbmdbXTtcbiAgICByZWNvbW1lbmRhdGlvbnM6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgY29uc3QgaXNzdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIENoZWNrIG9ubGluZSBzdGF0dXNcbiAgICBpZiAoIXRoaXMuaXNPbmxpbmUpIHtcbiAgICAgIGlzc3Vlcy5wdXNoKCdDdXJyZW50bHkgb2ZmbGluZScpO1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0Nvbm5lY3QgdG8gaW50ZXJuZXQgZm9yIGZ1bGwgZnVuY3Rpb25hbGl0eScpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHN0b3JhZ2VcbiAgICBjb25zdCBzdG9yYWdlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0U3RvcmFnZUluZm8oKTtcbiAgICBjb25zdCB1c2FnZVBlcmNlbnQgPSAoc3RvcmFnZUluZm8udXNlZCAvIHN0b3JhZ2VJbmZvLnRvdGFsKSAqIDEwMDtcblxuICAgIGlmICh1c2FnZVBlcmNlbnQgPiA5MCkge1xuICAgICAgaXNzdWVzLnB1c2goJ1N0b3JhZ2UgbmVhcmx5IGZ1bGwnKTtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdDbGVhciBvZmZsaW5lIGRhdGEgb3IgaW5jcmVhc2Ugc3RvcmFnZSBsaW1pdCcpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGxhc3Qgc3luY1xuICAgIGlmICh0aGlzLmlzRGF0YVN0YWxlKDMwKSkge1xuICAgICAgaXNzdWVzLnB1c2goJ0RhdGEgbWF5IGJlIHN0YWxlJyk7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnU3luYyB3aXRoIHNlcnZlciB3aGVuIG9ubGluZScpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNlcnZpY2Ugd29ya2VyXG4gICAgaWYgKCEoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikpIHtcbiAgICAgIGlzc3Vlcy5wdXNoKCdTZXJ2aWNlIHdvcmtlciBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnVXNlIGEgbW9kZXJuIGJyb3dzZXIgZm9yIG9mZmxpbmUgZmVhdHVyZXMnKTtcbiAgICB9XG5cbiAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XG4gICAgaWYgKGlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0YXR1cyA9ICdoZWFsdGh5JztcbiAgICB9IGVsc2UgaWYgKGlzc3Vlcy5sZW5ndGggPD0gMikge1xuICAgICAgc3RhdHVzID0gJ2RlZ3JhZGVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gJ3VuaGVhbHRoeSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzLCBpc3N1ZXMsIHJlY29tbWVuZGF0aW9ucyB9O1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBvZmZsaW5lTWFuYWdlciA9IG5ldyBPZmZsaW5lTWFuYWdlcigpO1xuZXhwb3J0IGRlZmF1bHQgb2ZmbGluZU1hbmFnZXI7XG4iXSwibmFtZXMiOlsib2ZmbGluZVN0b3JhZ2UiLCJPZmZsaW5lTWFuYWdlciIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaXNPbmxpbmUiLCJub3RpZnlMaXN0ZW5lcnMiLCJzdGFydFN5bmMiLCJkb2N1bWVudCIsImhpZGRlbiIsImxvYWRMYXN0U3luYyIsImxhc3RTeW5jU3RyIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImxhc3RTeW5jIiwiRGF0ZSIsInNhdmVMYXN0U3luYyIsInNldEl0ZW0iLCJ0b0lTT1N0cmluZyIsImdldFN0YXR1cyIsInBlbmRpbmdTeW5jIiwiY29uZmxpY3RzIiwic3RvcmFnZVVzZWQiLCJzdG9yYWdlVG90YWwiLCJnZXRTeW5jUHJvZ3Jlc3MiLCJzeW5jUHJvZ3Jlc3MiLCJhZGRTdGF0dXNMaXN0ZW5lciIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYWRkIiwiZGVsZXRlIiwiYWRkU3luY1Byb2dyZXNzTGlzdGVuZXIiLCJzeW5jTGlzdGVuZXJzIiwic3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiY29uc29sZSIsIm5vdGlmeVN5bmNMaXN0ZW5lcnMiLCJsb2ciLCJzdG9yYWdlSW5mbyIsImdldFN0b3JhZ2VJbmZvIiwidG90YWwiLCJjb21wbGV0ZWQiLCJmYWlsZWQiLCJjdXJyZW50IiwicHJvY2Vzc1N5bmNRdWV1ZSIsImZvcmNlU3luYyIsImRldGVjdENvbmZsaWN0cyIsInJlc29sdmVDb25mbGljdCIsImNvbmZsaWN0SWQiLCJyZXNvbHV0aW9uIiwiaW5mbyIsImVzdGltYXRlZFNpemUiLCJ0b3RhbFN0b3JhZ2UiLCJ1c2VkIiwiYnlUeXBlIiwiY2xlYXJPZmZsaW5lRGF0YSIsImNsZWFyQWxsRGF0YSIsInJlbW92ZUl0ZW0iLCJpc0RhdGFTdGFsZSIsIm1heEFnZU1pbnV0ZXMiLCJub3ciLCJkaWZmTWludXRlcyIsImdldFRpbWUiLCJnZXRPZmZsaW5lQ2FwYWJpbGl0aWVzIiwiY2FuV29ya09mZmxpbmUiLCJmZWF0dXJlcyIsImxpbWl0YXRpb25zIiwicmVnaXN0ZXJCYWNrZ3JvdW5kU3luYyIsIm5hdmlnYXRvciIsIlNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24iLCJwcm90b3R5cGUiLCJyZWdpc3RyYXRpb24iLCJzZXJ2aWNlV29ya2VyIiwicmVhZHkiLCJzeW5jIiwicmVnaXN0ZXIiLCJyZXF1ZXN0Tm90aWZpY2F0aW9uUGVybWlzc2lvbiIsIk5vdGlmaWNhdGlvbiIsInBlcm1pc3Npb24iLCJyZXF1ZXN0UGVybWlzc2lvbiIsImhlYWx0aENoZWNrIiwiaXNzdWVzIiwicmVjb21tZW5kYXRpb25zIiwicHVzaCIsInVzYWdlUGVyY2VudCIsImxlbmd0aCIsIm9uTGluZSIsIlNldCIsIm9mZmxpbmVNYW5hZ2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/offline-manager.ts\n"));

/***/ })

});