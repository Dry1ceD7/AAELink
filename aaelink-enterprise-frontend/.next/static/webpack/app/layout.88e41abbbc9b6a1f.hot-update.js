"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/offline-storage.ts":
/*!********************************!*\
  !*** ./lib/offline-storage.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   offlineStorage: () => (/* binding */ offlineStorage)\n/* harmony export */ });\n/**\n * AAELink Enterprise Offline Storage\n * IndexedDB-based local storage with conflict resolution\n * Version: 1.2.0\n */ class OfflineStorage {\n    async init() {\n        return new Promise((resolve, reject)=>{\n            const request = indexedDB.open(this.dbName, this.version);\n            request.onerror = ()=>reject(request.error);\n            request.onsuccess = ()=>{\n                this.db = request.result;\n                resolve();\n            };\n            request.onupgradeneeded = (event)=>{\n                const db = event.target.result;\n                // Create object stores\n                if (!db.objectStoreNames.contains('messages')) {\n                    const messageStore = db.createObjectStore('messages', {\n                        keyPath: 'id'\n                    });\n                    messageStore.createIndex('timestamp', 'timestamp');\n                    messageStore.createIndex('synced', 'synced');\n                    messageStore.createIndex('type', 'type');\n                }\n                if (!db.objectStoreNames.contains('files')) {\n                    const fileStore = db.createObjectStore('files', {\n                        keyPath: 'id'\n                    });\n                    fileStore.createIndex('timestamp', 'timestamp');\n                    fileStore.createIndex('synced', 'synced');\n                    fileStore.createIndex('channelId', 'channelId');\n                }\n                if (!db.objectStoreNames.contains('events')) {\n                    const eventStore = db.createObjectStore('events', {\n                        keyPath: 'id'\n                    });\n                    eventStore.createIndex('timestamp', 'timestamp');\n                    eventStore.createIndex('synced', 'synced');\n                    eventStore.createIndex('startDate', 'startDate');\n                }\n                if (!db.objectStoreNames.contains('users')) {\n                    const userStore = db.createObjectStore('users', {\n                        keyPath: 'id'\n                    });\n                    userStore.createIndex('timestamp', 'timestamp');\n                    userStore.createIndex('synced', 'synced');\n                }\n                if (!db.objectStoreNames.contains('syncQueue')) {\n                    const syncStore = db.createObjectStore('syncQueue', {\n                        keyPath: 'id'\n                    });\n                    syncStore.createIndex('timestamp', 'timestamp');\n                    syncStore.createIndex('retries', 'retries');\n                }\n                if (!db.objectStoreNames.contains('conflicts')) {\n                    const conflictStore = db.createObjectStore('conflicts', {\n                        keyPath: 'id'\n                    });\n                    conflictStore.createIndex('timestamp', 'timestamp');\n                    conflictStore.createIndex('resolved', 'resolved');\n                }\n            };\n        });\n    }\n    setupEventListeners() {\n        if (false) {}\n        window.addEventListener('online', ()=>{\n            this.isOnline = true;\n            this.processSyncQueue();\n        });\n        window.addEventListener('offline', ()=>{\n            this.isOnline = false;\n        });\n    }\n    // Message operations\n    async saveMessage(message) {\n        const offlineData = {\n            id: this.generateId(),\n            type: 'message',\n            data: message,\n            timestamp: Date.now(),\n            synced: false\n        };\n        await this.saveToStore('messages', offlineData);\n        if (this.isOnline) {\n            this.addToSyncQueue('create', 'message', message);\n        }\n        return offlineData.id;\n    }\n    async getMessages(channelId) {\n        const messages = await this.getAllFromStore('messages');\n        if (channelId) {\n            return messages.filter((msg)=>msg.data.channelId === channelId).map((msg)=>msg.data).sort((a, b)=>a.timestamp - b.timestamp);\n        }\n        return messages.map((msg)=>msg.data).sort((a, b)=>a.timestamp - b.timestamp);\n    }\n    async updateMessage(id, updates) {\n        const message = await this.getFromStore('messages', id);\n        if (message) {\n            message.data = {\n                ...message.data,\n                ...updates\n            };\n            message.synced = false;\n            message.timestamp = Date.now();\n            await this.saveToStore('messages', message);\n            if (this.isOnline) {\n                this.addToSyncQueue('update', 'message', message.data);\n            }\n        }\n    }\n    async deleteMessage(id) {\n        await this.deleteFromStore('messages', id);\n        if (this.isOnline) {\n            this.addToSyncQueue('delete', 'message', {\n                id\n            });\n        }\n    }\n    // File operations\n    async saveFile(file) {\n        const offlineData = {\n            id: this.generateId(),\n            type: 'file',\n            data: file,\n            timestamp: Date.now(),\n            synced: false\n        };\n        await this.saveToStore('files', offlineData);\n        if (this.isOnline) {\n            this.addToSyncQueue('create', 'file', file);\n        }\n        return offlineData.id;\n    }\n    async getFiles(channelId) {\n        const files = await this.getAllFromStore('files');\n        if (channelId) {\n            return files.filter((file)=>file.data.channelId === channelId).map((file)=>file.data).sort((a, b)=>b.timestamp - a.timestamp);\n        }\n        return files.map((file)=>file.data).sort((a, b)=>b.timestamp - a.timestamp);\n    }\n    // Event operations\n    async saveEvent(event) {\n        const offlineData = {\n            id: this.generateId(),\n            type: 'event',\n            data: event,\n            timestamp: Date.now(),\n            synced: false\n        };\n        await this.saveToStore('events', offlineData);\n        if (this.isOnline) {\n            this.addToSyncQueue('create', 'event', event);\n        }\n        return offlineData.id;\n    }\n    async getEvents(startDate, endDate) {\n        const events = await this.getAllFromStore('events');\n        let filteredEvents = events.map((event)=>event.data);\n        if (startDate) {\n            filteredEvents = filteredEvents.filter((event)=>new Date(event.startDate) >= startDate);\n        }\n        if (endDate) {\n            filteredEvents = filteredEvents.filter((event)=>new Date(event.startDate) <= endDate);\n        }\n        return filteredEvents.sort((a, b)=>new Date(a.startDate).getTime() - new Date(b.startDate).getTime());\n    }\n    // User operations\n    async saveUser(user) {\n        const offlineData = {\n            id: user.id || this.generateId(),\n            type: 'user',\n            data: user,\n            timestamp: Date.now(),\n            synced: false\n        };\n        await this.saveToStore('users', offlineData);\n        if (this.isOnline) {\n            this.addToSyncQueue('update', 'user', user);\n        }\n        return offlineData.id;\n    }\n    async getUser(id) {\n        const user = await this.getFromStore('users', id);\n        return user ? user.data : null;\n    }\n    // Conflict resolution\n    async detectConflict(localData, serverData) {\n        if (!localData || !serverData) return false;\n        const localTimestamp = localData.timestamp || localData.updatedAt;\n        const serverTimestamp = serverData.timestamp || serverData.updatedAt;\n        return localTimestamp !== serverTimestamp;\n    }\n    async resolveConflict(conflictId, resolution) {\n        const conflict = await this.getFromStore('conflicts', conflictId);\n        if (!conflict) return;\n        let resolvedData;\n        switch(resolution){\n            case 'local':\n                resolvedData = conflict.localVersion;\n                break;\n            case 'server':\n                resolvedData = conflict.serverVersion;\n                break;\n            case 'merge':\n                resolvedData = this.mergeData(conflict.localVersion, conflict.serverVersion);\n                break;\n        }\n        // Update the original data\n        await this.saveToStore(conflict.type, {\n            id: conflict.id,\n            type: conflict.type,\n            data: resolvedData,\n            timestamp: Date.now(),\n            synced: true\n        });\n        // Remove from conflicts\n        await this.deleteFromStore('conflicts', conflictId);\n    }\n    mergeData(local, server) {\n        // Simple merge strategy - prefer non-null values\n        const merged = {\n            ...server\n        };\n        for(const key in local){\n            if (local[key] !== null && local[key] !== undefined) {\n                if (typeof local[key] === 'object' && typeof server[key] === 'object') {\n                    merged[key] = this.mergeData(local[key], server[key]);\n                } else {\n                    merged[key] = local[key];\n                }\n            }\n        }\n        return merged;\n    }\n    // Sync operations\n    async addToSyncQueue(action, type, data) {\n        const syncItem = {\n            id: this.generateId(),\n            action,\n            data,\n            timestamp: Date.now(),\n            retries: 0,\n            maxRetries: 3\n        };\n        await this.saveToStore('syncQueue', syncItem);\n        this.syncQueue.push(syncItem);\n        if (this.isOnline && !this.syncInProgress) {\n            this.processSyncQueue();\n        }\n    }\n    async processSyncQueue() {\n        if (this.syncInProgress || !this.isOnline) return;\n        this.syncInProgress = true;\n        try {\n            const queue = await this.getAllFromStore('syncQueue');\n            for (const item of queue){\n                try {\n                    await this.syncItem(item);\n                    await this.deleteFromStore('syncQueue', item.id);\n                } catch (error) {\n                    console.error('Sync failed for item:', item.id, error);\n                    item.retries++;\n                    if (item.retries >= item.maxRetries) {\n                        await this.deleteFromStore('syncQueue', item.id);\n                    } else {\n                        await this.saveToStore('syncQueue', item);\n                    }\n                }\n            }\n        } finally{\n            this.syncInProgress = false;\n        }\n    }\n    async syncItem(item) {\n        const { action, data, type } = item;\n        let url = '';\n        let method = 'POST';\n        switch(type){\n            case 'message':\n                url = '/api/chat/messages';\n                method = action === 'delete' ? 'DELETE' : 'POST';\n                break;\n            case 'file':\n                url = '/api/files/upload';\n                method = 'POST';\n                break;\n            case 'event':\n                url = '/api/calendar/events';\n                method = action === 'delete' ? 'DELETE' : 'POST';\n                break;\n            case 'user':\n                url = '/api/users/profile';\n                method = 'PUT';\n                break;\n        }\n        const response = await fetch(url, {\n            method,\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': \"Bearer \".concat(this.getAuthToken())\n            },\n            body: JSON.stringify(data)\n        });\n        if (!response.ok) {\n            throw new Error(\"Sync failed: \".concat(response.statusText));\n        }\n    }\n    getAuthToken() {\n        return localStorage.getItem('authToken') || '';\n    }\n    // Utility methods\n    generateId() {\n        return \"\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n    }\n    async saveToStore(storeName, data) {\n        if (!this.db) throw new Error('Database not initialized');\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            const request = store.put(data);\n            request.onsuccess = ()=>resolve();\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    async getFromStore(storeName, id) {\n        if (!this.db) throw new Error('Database not initialized');\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readonly');\n            const store = transaction.objectStore(storeName);\n            const request = store.get(id);\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    async getAllFromStore(storeName) {\n        if (!this.db) throw new Error('Database not initialized');\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readonly');\n            const store = transaction.objectStore(storeName);\n            const request = store.getAll();\n            request.onsuccess = ()=>resolve(request.result || []);\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    async deleteFromStore(storeName, id) {\n        if (!this.db) throw new Error('Database not initialized');\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            const request = store.delete(id);\n            request.onsuccess = ()=>resolve();\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    // Public API\n    async clearAllData() {\n        if (!this.db) return;\n        const storeNames = [\n            'messages',\n            'files',\n            'events',\n            'users',\n            'syncQueue',\n            'conflicts'\n        ];\n        for (const storeName of storeNames){\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            await store.clear();\n        }\n    }\n    async getStorageInfo() {\n        const storeNames = [\n            'messages',\n            'files',\n            'events',\n            'users'\n        ];\n        const byType = {};\n        let total = 0;\n        for (const storeName of storeNames){\n            const count = await this.getStoreCount(storeName);\n            byType[storeName] = count;\n            total += count;\n        }\n        return {\n            total,\n            byType\n        };\n    }\n    async getStoreCount(storeName) {\n        if (!this.db) return 0;\n        return new Promise((resolve, reject)=>{\n            const transaction = this.db.transaction([\n                storeName\n            ], 'readonly');\n            const store = transaction.objectStore(storeName);\n            const request = store.count();\n            request.onsuccess = ()=>resolve(request.result);\n            request.onerror = ()=>reject(request.error);\n        });\n    }\n    constructor(){\n        this.dbName = 'AAELinkOffline';\n        this.version = 1;\n        this.db = null;\n        this.syncQueue = [];\n        this.isOnline = navigator.onLine;\n        this.syncInProgress = false;\n        this.init();\n        this.setupEventListeners();\n    }\n}\n// Export singleton instance\nconst offlineStorage = new OfflineStorage();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (offlineStorage);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9vZmZsaW5lLXN0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7OztDQUlDLEdBc0JELE1BQU1BO0lBYUosTUFBY0MsT0FBc0I7UUFDbEMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQzNCLE1BQU1DLFVBQVVDLFVBQVVDLElBQUksQ0FBQyxJQUFJLENBQUNDLE1BQU0sRUFBRSxJQUFJLENBQUNDLE9BQU87WUFFeERKLFFBQVFLLE9BQU8sR0FBRyxJQUFNTixPQUFPQyxRQUFRTSxLQUFLO1lBQzVDTixRQUFRTyxTQUFTLEdBQUc7Z0JBQ2xCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUixRQUFRUyxNQUFNO2dCQUN4Qlg7WUFDRjtZQUVBRSxRQUFRVSxlQUFlLEdBQUcsQ0FBQ0M7Z0JBQ3pCLE1BQU1ILEtBQUssTUFBT0ksTUFBTSxDQUFzQkgsTUFBTTtnQkFFcEQsdUJBQXVCO2dCQUN2QixJQUFJLENBQUNELEdBQUdLLGdCQUFnQixDQUFDQyxRQUFRLENBQUMsYUFBYTtvQkFDN0MsTUFBTUMsZUFBZVAsR0FBR1EsaUJBQWlCLENBQUMsWUFBWTt3QkFBRUMsU0FBUztvQkFBSztvQkFDdEVGLGFBQWFHLFdBQVcsQ0FBQyxhQUFhO29CQUN0Q0gsYUFBYUcsV0FBVyxDQUFDLFVBQVU7b0JBQ25DSCxhQUFhRyxXQUFXLENBQUMsUUFBUTtnQkFDbkM7Z0JBRUEsSUFBSSxDQUFDVixHQUFHSyxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDLFVBQVU7b0JBQzFDLE1BQU1LLFlBQVlYLEdBQUdRLGlCQUFpQixDQUFDLFNBQVM7d0JBQUVDLFNBQVM7b0JBQUs7b0JBQ2hFRSxVQUFVRCxXQUFXLENBQUMsYUFBYTtvQkFDbkNDLFVBQVVELFdBQVcsQ0FBQyxVQUFVO29CQUNoQ0MsVUFBVUQsV0FBVyxDQUFDLGFBQWE7Z0JBQ3JDO2dCQUVBLElBQUksQ0FBQ1YsR0FBR0ssZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQyxXQUFXO29C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SVgsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixNQUFNd0gsY0FBYyxJQUFJLENBQUMvRyxFQUFFLENBQUUrRyxXQUFXLENBQUM7Z0JBQUNEO2FBQVUsRUFBRTtZQUN0RCxNQUFNRSxRQUFRRCxZQUFZRSxXQUFXLENBQUNIO1lBQ3RDLE1BQU10SCxVQUFVd0gsTUFBTVksS0FBSztZQUUzQnBJLFFBQVFPLFNBQVMsR0FBRyxJQUFNVCxRQUFRRSxRQUFRUyxNQUFNO1lBQ2hEVCxRQUFRSyxPQUFPLEdBQUcsSUFBTU4sT0FBT0MsUUFBUU0sS0FBSztRQUM5QztJQUNGO0lBcGRBLGFBQWM7YUFQTkgsU0FBUzthQUNUQyxVQUFVO2FBQ1ZJLEtBQXlCO2FBQ3pCc0YsWUFBeUIsRUFBRTthQUMzQm5FLFdBQVcyRyxVQUFVQyxNQUFNO2FBQzNCdkMsaUJBQWlCO1FBR3ZCLElBQUksQ0FBQ3BHLElBQUk7UUFDVCxJQUFJLENBQUM0QixtQkFBbUI7SUFDMUI7QUFrZEY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWdILGlCQUFpQixJQUFJN0ksaUJBQWlCO0FBQ25ELGlFQUFlNkksY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2Q3eTFjZS9BQUVMaW5rLW5ldy9hYWVsaW5rLWVudGVycHJpc2UtZnJvbnRlbmQvbGliL29mZmxpbmUtc3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFBRUxpbmsgRW50ZXJwcmlzZSBPZmZsaW5lIFN0b3JhZ2VcbiAqIEluZGV4ZWREQi1iYXNlZCBsb2NhbCBzdG9yYWdlIHdpdGggY29uZmxpY3QgcmVzb2x1dGlvblxuICogVmVyc2lvbjogMS4yLjBcbiAqL1xuXG5pbnRlcmZhY2UgT2ZmbGluZURhdGEge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiAnbWVzc2FnZScgfCAnZmlsZScgfCAnZXZlbnQnIHwgJ3VzZXInO1xuICBkYXRhOiBhbnk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBzeW5jZWQ6IGJvb2xlYW47XG4gIGNvbmZsaWN0PzogYm9vbGVhbjtcbiAgc2VydmVyVmVyc2lvbj86IGFueTtcbiAgbG9jYWxWZXJzaW9uPzogYW55O1xufVxuXG5pbnRlcmZhY2UgU3luY1F1ZXVlIHtcbiAgaWQ6IHN0cmluZztcbiAgYWN0aW9uOiAnY3JlYXRlJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZSc7XG4gIGRhdGE6IGFueTtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIHJldHJpZXM6IG51bWJlcjtcbiAgbWF4UmV0cmllczogbnVtYmVyO1xufVxuXG5jbGFzcyBPZmZsaW5lU3RvcmFnZSB7XG4gIHByaXZhdGUgZGJOYW1lID0gJ0FBRUxpbmtPZmZsaW5lJztcbiAgcHJpdmF0ZSB2ZXJzaW9uID0gMTtcbiAgcHJpdmF0ZSBkYjogSURCRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzeW5jUXVldWU6IFN5bmNRdWV1ZVtdID0gW107XG4gIHByaXZhdGUgaXNPbmxpbmUgPSBuYXZpZ2F0b3Iub25MaW5lO1xuICBwcml2YXRlIHN5bmNJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4gcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcblxuICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGIgPSAoZXZlbnQudGFyZ2V0IGFzIElEQk9wZW5EQlJlcXVlc3QpLnJlc3VsdDtcblxuICAgICAgICAvLyBDcmVhdGUgb2JqZWN0IHN0b3Jlc1xuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ21lc3NhZ2VzJykpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgnbWVzc2FnZXMnLCB7IGtleVBhdGg6ICdpZCcgfSk7XG4gICAgICAgICAgbWVzc2FnZVN0b3JlLmNyZWF0ZUluZGV4KCd0aW1lc3RhbXAnLCAndGltZXN0YW1wJyk7XG4gICAgICAgICAgbWVzc2FnZVN0b3JlLmNyZWF0ZUluZGV4KCdzeW5jZWQnLCAnc3luY2VkJyk7XG4gICAgICAgICAgbWVzc2FnZVN0b3JlLmNyZWF0ZUluZGV4KCd0eXBlJywgJ3R5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnZmlsZXMnKSkge1xuICAgICAgICAgIGNvbnN0IGZpbGVTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdmaWxlcycsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgICBmaWxlU3RvcmUuY3JlYXRlSW5kZXgoJ3RpbWVzdGFtcCcsICd0aW1lc3RhbXAnKTtcbiAgICAgICAgICBmaWxlU3RvcmUuY3JlYXRlSW5kZXgoJ3N5bmNlZCcsICdzeW5jZWQnKTtcbiAgICAgICAgICBmaWxlU3RvcmUuY3JlYXRlSW5kZXgoJ2NoYW5uZWxJZCcsICdjaGFubmVsSWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnZXZlbnRzJykpIHtcbiAgICAgICAgICBjb25zdCBldmVudFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2V2ZW50cycsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgICBldmVudFN0b3JlLmNyZWF0ZUluZGV4KCd0aW1lc3RhbXAnLCAndGltZXN0YW1wJyk7XG4gICAgICAgICAgZXZlbnRTdG9yZS5jcmVhdGVJbmRleCgnc3luY2VkJywgJ3N5bmNlZCcpO1xuICAgICAgICAgIGV2ZW50U3RvcmUuY3JlYXRlSW5kZXgoJ3N0YXJ0RGF0ZScsICdzdGFydERhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygndXNlcnMnKSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCd1c2VycycsIHsga2V5UGF0aDogJ2lkJyB9KTtcbiAgICAgICAgICB1c2VyU3RvcmUuY3JlYXRlSW5kZXgoJ3RpbWVzdGFtcCcsICd0aW1lc3RhbXAnKTtcbiAgICAgICAgICB1c2VyU3RvcmUuY3JlYXRlSW5kZXgoJ3N5bmNlZCcsICdzeW5jZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnc3luY1F1ZXVlJykpIHtcbiAgICAgICAgICBjb25zdCBzeW5jU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZSgnc3luY1F1ZXVlJywgeyBrZXlQYXRoOiAnaWQnIH0pO1xuICAgICAgICAgIHN5bmNTdG9yZS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcpO1xuICAgICAgICAgIHN5bmNTdG9yZS5jcmVhdGVJbmRleCgncmV0cmllcycsICdyZXRyaWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoJ2NvbmZsaWN0cycpKSB7XG4gICAgICAgICAgY29uc3QgY29uZmxpY3RTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdjb25mbGljdHMnLCB7IGtleVBhdGg6ICdpZCcgfSk7XG4gICAgICAgICAgY29uZmxpY3RTdG9yZS5jcmVhdGVJbmRleCgndGltZXN0YW1wJywgJ3RpbWVzdGFtcCcpO1xuICAgICAgICAgIGNvbmZsaWN0U3RvcmUuY3JlYXRlSW5kZXgoJ3Jlc29sdmVkJywgJ3Jlc29sdmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHtcbiAgICAgIHRoaXMuaXNPbmxpbmUgPSB0cnVlO1xuICAgICAgdGhpcy5wcm9jZXNzU3luY1F1ZXVlKCk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHtcbiAgICAgIHRoaXMuaXNPbmxpbmUgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1lc3NhZ2Ugb3BlcmF0aW9uc1xuICBhc3luYyBzYXZlTWVzc2FnZShtZXNzYWdlOiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG9mZmxpbmVEYXRhOiBPZmZsaW5lRGF0YSA9IHtcbiAgICAgIGlkOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgIHR5cGU6ICdtZXNzYWdlJyxcbiAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBzeW5jZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMuc2F2ZVRvU3RvcmUoJ21lc3NhZ2VzJywgb2ZmbGluZURhdGEpO1xuXG4gICAgaWYgKHRoaXMuaXNPbmxpbmUpIHtcbiAgICAgIHRoaXMuYWRkVG9TeW5jUXVldWUoJ2NyZWF0ZScsICdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZmxpbmVEYXRhLmlkO1xuICB9XG5cbiAgYXN5bmMgZ2V0TWVzc2FnZXMoY2hhbm5lbElkPzogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdGhpcy5nZXRBbGxGcm9tU3RvcmUoJ21lc3NhZ2VzJyk7XG5cbiAgICBpZiAoY2hhbm5lbElkKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZXNcbiAgICAgICAgLmZpbHRlcihtc2cgPT4gbXNnLmRhdGEuY2hhbm5lbElkID09PSBjaGFubmVsSWQpXG4gICAgICAgIC5tYXAobXNnID0+IG1zZy5kYXRhKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS50aW1lc3RhbXAgLSBiLnRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcChtc2cgPT4gbXNnLmRhdGEpLnNvcnQoKGEsIGIpID0+IGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXApO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlTWVzc2FnZShpZDogc3RyaW5nLCB1cGRhdGVzOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5nZXRGcm9tU3RvcmUoJ21lc3NhZ2VzJywgaWQpO1xuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlLmRhdGEgPSB7IC4uLm1lc3NhZ2UuZGF0YSwgLi4udXBkYXRlcyB9O1xuICAgICAgbWVzc2FnZS5zeW5jZWQgPSBmYWxzZTtcbiAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgYXdhaXQgdGhpcy5zYXZlVG9TdG9yZSgnbWVzc2FnZXMnLCBtZXNzYWdlKTtcblxuICAgICAgaWYgKHRoaXMuaXNPbmxpbmUpIHtcbiAgICAgICAgdGhpcy5hZGRUb1N5bmNRdWV1ZSgndXBkYXRlJywgJ21lc3NhZ2UnLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZU1lc3NhZ2UoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlRnJvbVN0b3JlKCdtZXNzYWdlcycsIGlkKTtcblxuICAgIGlmICh0aGlzLmlzT25saW5lKSB7XG4gICAgICB0aGlzLmFkZFRvU3luY1F1ZXVlKCdkZWxldGUnLCAnbWVzc2FnZScsIHsgaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlsZSBvcGVyYXRpb25zXG4gIGFzeW5jIHNhdmVGaWxlKGZpbGU6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgb2ZmbGluZURhdGE6IE9mZmxpbmVEYXRhID0ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgZGF0YTogZmlsZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHN5bmNlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy5zYXZlVG9TdG9yZSgnZmlsZXMnLCBvZmZsaW5lRGF0YSk7XG5cbiAgICBpZiAodGhpcy5pc09ubGluZSkge1xuICAgICAgdGhpcy5hZGRUb1N5bmNRdWV1ZSgnY3JlYXRlJywgJ2ZpbGUnLCBmaWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2ZmbGluZURhdGEuaWQ7XG4gIH1cblxuICBhc3luYyBnZXRGaWxlcyhjaGFubmVsSWQ/OiBzdHJpbmcpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmdldEFsbEZyb21TdG9yZSgnZmlsZXMnKTtcblxuICAgIGlmIChjaGFubmVsSWQpIHtcbiAgICAgIHJldHVybiBmaWxlc1xuICAgICAgICAuZmlsdGVyKGZpbGUgPT4gZmlsZS5kYXRhLmNoYW5uZWxJZCA9PT0gY2hhbm5lbElkKVxuICAgICAgICAubWFwKGZpbGUgPT4gZmlsZS5kYXRhKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAgLSBhLnRpbWVzdGFtcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGVzLm1hcChmaWxlID0+IGZpbGUuZGF0YSkuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAgLSBhLnRpbWVzdGFtcCk7XG4gIH1cblxuICAvLyBFdmVudCBvcGVyYXRpb25zXG4gIGFzeW5jIHNhdmVFdmVudChldmVudDogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBvZmZsaW5lRGF0YTogT2ZmbGluZURhdGEgPSB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgZGF0YTogZXZlbnQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBzeW5jZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGF3YWl0IHRoaXMuc2F2ZVRvU3RvcmUoJ2V2ZW50cycsIG9mZmxpbmVEYXRhKTtcblxuICAgIGlmICh0aGlzLmlzT25saW5lKSB7XG4gICAgICB0aGlzLmFkZFRvU3luY1F1ZXVlKCdjcmVhdGUnLCAnZXZlbnQnLCBldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZmxpbmVEYXRhLmlkO1xuICB9XG5cbiAgYXN5bmMgZ2V0RXZlbnRzKHN0YXJ0RGF0ZT86IERhdGUsIGVuZERhdGU/OiBEYXRlKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMuZ2V0QWxsRnJvbVN0b3JlKCdldmVudHMnKTtcbiAgICBsZXQgZmlsdGVyZWRFdmVudHMgPSBldmVudHMubWFwKGV2ZW50ID0+IGV2ZW50LmRhdGEpO1xuXG4gICAgaWYgKHN0YXJ0RGF0ZSkge1xuICAgICAgZmlsdGVyZWRFdmVudHMgPSBmaWx0ZXJlZEV2ZW50cy5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgbmV3IERhdGUoZXZlbnQuc3RhcnREYXRlKSA+PSBzdGFydERhdGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVuZERhdGUpIHtcbiAgICAgIGZpbHRlcmVkRXZlbnRzID0gZmlsdGVyZWRFdmVudHMuZmlsdGVyKGV2ZW50ID0+XG4gICAgICAgIG5ldyBEYXRlKGV2ZW50LnN0YXJ0RGF0ZSkgPD0gZW5kRGF0ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWRFdmVudHMuc29ydCgoYSwgYikgPT5cbiAgICAgIG5ldyBEYXRlKGEuc3RhcnREYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLnN0YXJ0RGF0ZSkuZ2V0VGltZSgpXG4gICAgKTtcbiAgfVxuXG4gIC8vIFVzZXIgb3BlcmF0aW9uc1xuICBhc3luYyBzYXZlVXNlcih1c2VyOiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG9mZmxpbmVEYXRhOiBPZmZsaW5lRGF0YSA9IHtcbiAgICAgIGlkOiB1c2VyLmlkIHx8IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgdHlwZTogJ3VzZXInLFxuICAgICAgZGF0YTogdXNlcixcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHN5bmNlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy5zYXZlVG9TdG9yZSgndXNlcnMnLCBvZmZsaW5lRGF0YSk7XG5cbiAgICBpZiAodGhpcy5pc09ubGluZSkge1xuICAgICAgdGhpcy5hZGRUb1N5bmNRdWV1ZSgndXBkYXRlJywgJ3VzZXInLCB1c2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2ZmbGluZURhdGEuaWQ7XG4gIH1cblxuICBhc3luYyBnZXRVc2VyKGlkOiBzdHJpbmcpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5nZXRGcm9tU3RvcmUoJ3VzZXJzJywgaWQpO1xuICAgIHJldHVybiB1c2VyID8gdXNlci5kYXRhIDogbnVsbDtcbiAgfVxuXG4gIC8vIENvbmZsaWN0IHJlc29sdXRpb25cbiAgYXN5bmMgZGV0ZWN0Q29uZmxpY3QobG9jYWxEYXRhOiBhbnksIHNlcnZlckRhdGE6IGFueSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghbG9jYWxEYXRhIHx8ICFzZXJ2ZXJEYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBsb2NhbFRpbWVzdGFtcCA9IGxvY2FsRGF0YS50aW1lc3RhbXAgfHwgbG9jYWxEYXRhLnVwZGF0ZWRBdDtcbiAgICBjb25zdCBzZXJ2ZXJUaW1lc3RhbXAgPSBzZXJ2ZXJEYXRhLnRpbWVzdGFtcCB8fCBzZXJ2ZXJEYXRhLnVwZGF0ZWRBdDtcblxuICAgIHJldHVybiBsb2NhbFRpbWVzdGFtcCAhPT0gc2VydmVyVGltZXN0YW1wO1xuICB9XG5cbiAgYXN5bmMgcmVzb2x2ZUNvbmZsaWN0KGNvbmZsaWN0SWQ6IHN0cmluZywgcmVzb2x1dGlvbjogJ2xvY2FsJyB8ICdzZXJ2ZXInIHwgJ21lcmdlJyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNvbmZsaWN0ID0gYXdhaXQgdGhpcy5nZXRGcm9tU3RvcmUoJ2NvbmZsaWN0cycsIGNvbmZsaWN0SWQpO1xuICAgIGlmICghY29uZmxpY3QpIHJldHVybjtcblxuICAgIGxldCByZXNvbHZlZERhdGE7XG5cbiAgICBzd2l0Y2ggKHJlc29sdXRpb24pIHtcbiAgICAgIGNhc2UgJ2xvY2FsJzpcbiAgICAgICAgcmVzb2x2ZWREYXRhID0gY29uZmxpY3QubG9jYWxWZXJzaW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgIHJlc29sdmVkRGF0YSA9IGNvbmZsaWN0LnNlcnZlclZlcnNpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWVyZ2UnOlxuICAgICAgICByZXNvbHZlZERhdGEgPSB0aGlzLm1lcmdlRGF0YShjb25mbGljdC5sb2NhbFZlcnNpb24sIGNvbmZsaWN0LnNlcnZlclZlcnNpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIG9yaWdpbmFsIGRhdGFcbiAgICBhd2FpdCB0aGlzLnNhdmVUb1N0b3JlKGNvbmZsaWN0LnR5cGUsIHtcbiAgICAgIGlkOiBjb25mbGljdC5pZCxcbiAgICAgIHR5cGU6IGNvbmZsaWN0LnR5cGUsXG4gICAgICBkYXRhOiByZXNvbHZlZERhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBzeW5jZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBmcm9tIGNvbmZsaWN0c1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlRnJvbVN0b3JlKCdjb25mbGljdHMnLCBjb25mbGljdElkKTtcbiAgfVxuXG4gIHByaXZhdGUgbWVyZ2VEYXRhKGxvY2FsOiBhbnksIHNlcnZlcjogYW55KTogYW55IHtcbiAgICAvLyBTaW1wbGUgbWVyZ2Ugc3RyYXRlZ3kgLSBwcmVmZXIgbm9uLW51bGwgdmFsdWVzXG4gICAgY29uc3QgbWVyZ2VkID0geyAuLi5zZXJ2ZXIgfTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGxvY2FsKSB7XG4gICAgICBpZiAobG9jYWxba2V5XSAhPT0gbnVsbCAmJiBsb2NhbFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2VydmVyW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLm1lcmdlRGF0YShsb2NhbFtrZXldLCBzZXJ2ZXJba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBsb2NhbFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIC8vIFN5bmMgb3BlcmF0aW9uc1xuICBwcml2YXRlIGFzeW5jIGFkZFRvU3luY1F1ZXVlKGFjdGlvbjogJ2NyZWF0ZScgfCAndXBkYXRlJyB8ICdkZWxldGUnLCB0eXBlOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN5bmNJdGVtOiBTeW5jUXVldWUgPSB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICBhY3Rpb24sXG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgcmV0cmllczogMCxcbiAgICAgIG1heFJldHJpZXM6IDNcbiAgICB9O1xuXG4gICAgYXdhaXQgdGhpcy5zYXZlVG9TdG9yZSgnc3luY1F1ZXVlJywgc3luY0l0ZW0pO1xuICAgIHRoaXMuc3luY1F1ZXVlLnB1c2goc3luY0l0ZW0pO1xuXG4gICAgaWYgKHRoaXMuaXNPbmxpbmUgJiYgIXRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucHJvY2Vzc1N5bmNRdWV1ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NTeW5jUXVldWUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuc3luY0luUHJvZ3Jlc3MgfHwgIXRoaXMuaXNPbmxpbmUpIHJldHVybjtcblxuICAgIHRoaXMuc3luY0luUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHF1ZXVlID0gYXdhaXQgdGhpcy5nZXRBbGxGcm9tU3RvcmUoJ3N5bmNRdWV1ZScpO1xuXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcXVldWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnN5bmNJdGVtKGl0ZW0pO1xuICAgICAgICAgIGF3YWl0IHRoaXMuZGVsZXRlRnJvbVN0b3JlKCdzeW5jUXVldWUnLCBpdGVtLmlkKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdTeW5jIGZhaWxlZCBmb3IgaXRlbTonLCBpdGVtLmlkLCBlcnJvcik7XG5cbiAgICAgICAgICBpdGVtLnJldHJpZXMrKztcbiAgICAgICAgICBpZiAoaXRlbS5yZXRyaWVzID49IGl0ZW0ubWF4UmV0cmllcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVGcm9tU3RvcmUoJ3N5bmNRdWV1ZScsIGl0ZW0uaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVUb1N0b3JlKCdzeW5jUXVldWUnLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc3luY0l0ZW0oaXRlbTogU3luY1F1ZXVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBhY3Rpb24sIGRhdGEsIHR5cGUgfSA9IGl0ZW07XG5cbiAgICBsZXQgdXJsID0gJyc7XG4gICAgbGV0IG1ldGhvZCA9ICdQT1NUJztcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHVybCA9ICcvYXBpL2NoYXQvbWVzc2FnZXMnO1xuICAgICAgICBtZXRob2QgPSBhY3Rpb24gPT09ICdkZWxldGUnID8gJ0RFTEVURScgOiAnUE9TVCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgIHVybCA9ICcvYXBpL2ZpbGVzL3VwbG9hZCc7XG4gICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIHVybCA9ICcvYXBpL2NhbGVuZGFyL2V2ZW50cyc7XG4gICAgICAgIG1ldGhvZCA9IGFjdGlvbiA9PT0gJ2RlbGV0ZScgPyAnREVMRVRFJyA6ICdQT1NUJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1c2VyJzpcbiAgICAgICAgdXJsID0gJy9hcGkvdXNlcnMvcHJvZmlsZSc7XG4gICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmdldEF1dGhUb2tlbigpfWBcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTeW5jIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0QXV0aFRva2VuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoVG9rZW4nKSB8fCAnJztcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZVRvU3RvcmUoc3RvcmVOYW1lOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUucHV0KGRhdGEpO1xuXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0RnJvbVN0b3JlKHN0b3JlTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcignRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0QWxsRnJvbVN0b3JlKHN0b3JlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGlmICghdGhpcy5kYikgdGhyb3cgbmV3IEVycm9yKCdEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRoaXMuZGIhLnRyYW5zYWN0aW9uKFtzdG9yZU5hbWVdLCAncmVhZG9ubHknKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXRBbGwoKTtcblxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0IHx8IFtdKTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZGVsZXRlRnJvbVN0b3JlKHN0b3JlTmFtZTogc3RyaW5nLCBpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFiYXNlIG5vdCBpbml0aWFsaXplZCcpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYiEudHJhbnNhY3Rpb24oW3N0b3JlTmFtZV0sICdyZWFkd3JpdGUnKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoaWQpO1xuXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoKTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcbiAgYXN5bmMgY2xlYXJBbGxEYXRhKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5kYikgcmV0dXJuO1xuXG4gICAgY29uc3Qgc3RvcmVOYW1lcyA9IFsnbWVzc2FnZXMnLCAnZmlsZXMnLCAnZXZlbnRzJywgJ3VzZXJzJywgJ3N5bmNRdWV1ZScsICdjb25mbGljdHMnXTtcblxuICAgIGZvciAoY29uc3Qgc3RvcmVOYW1lIG9mIHN0b3JlTmFtZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgYXdhaXQgc3RvcmUuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTdG9yYWdlSW5mbygpOiBQcm9taXNlPHsgdG90YWw6IG51bWJlcjsgYnlUeXBlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+IH0+IHtcbiAgICBjb25zdCBzdG9yZU5hbWVzID0gWydtZXNzYWdlcycsICdmaWxlcycsICdldmVudHMnLCAndXNlcnMnXTtcbiAgICBjb25zdCBieVR5cGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBsZXQgdG90YWwgPSAwO1xuXG4gICAgZm9yIChjb25zdCBzdG9yZU5hbWUgb2Ygc3RvcmVOYW1lcykge1xuICAgICAgY29uc3QgY291bnQgPSBhd2FpdCB0aGlzLmdldFN0b3JlQ291bnQoc3RvcmVOYW1lKTtcbiAgICAgIGJ5VHlwZVtzdG9yZU5hbWVdID0gY291bnQ7XG4gICAgICB0b3RhbCArPSBjb3VudDtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0b3RhbCwgYnlUeXBlIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFN0b3JlQ291bnQoc3RvcmVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghdGhpcy5kYikgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiIS50cmFuc2FjdGlvbihbc3RvcmVOYW1lXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY291bnQoKTtcblxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiByZXNvbHZlKHJlcXVlc3QucmVzdWx0KTtcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9ICgpID0+IHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgb2ZmbGluZVN0b3JhZ2UgPSBuZXcgT2ZmbGluZVN0b3JhZ2UoKTtcbmV4cG9ydCBkZWZhdWx0IG9mZmxpbmVTdG9yYWdlO1xuIl0sIm5hbWVzIjpbIk9mZmxpbmVTdG9yYWdlIiwiaW5pdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdCIsImluZGV4ZWREQiIsIm9wZW4iLCJkYk5hbWUiLCJ2ZXJzaW9uIiwib25lcnJvciIsImVycm9yIiwib25zdWNjZXNzIiwiZGIiLCJyZXN1bHQiLCJvbnVwZ3JhZGVuZWVkZWQiLCJldmVudCIsInRhcmdldCIsIm9iamVjdFN0b3JlTmFtZXMiLCJjb250YWlucyIsIm1lc3NhZ2VTdG9yZSIsImNyZWF0ZU9iamVjdFN0b3JlIiwia2V5UGF0aCIsImNyZWF0ZUluZGV4IiwiZmlsZVN0b3JlIiwiZXZlbnRTdG9yZSIsInVzZXJTdG9yZSIsInN5bmNTdG9yZSIsImNvbmZsaWN0U3RvcmUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzT25saW5lIiwicHJvY2Vzc1N5bmNRdWV1ZSIsInNhdmVNZXNzYWdlIiwibWVzc2FnZSIsIm9mZmxpbmVEYXRhIiwiaWQiLCJnZW5lcmF0ZUlkIiwidHlwZSIsImRhdGEiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic3luY2VkIiwic2F2ZVRvU3RvcmUiLCJhZGRUb1N5bmNRdWV1ZSIsImdldE1lc3NhZ2VzIiwiY2hhbm5lbElkIiwibWVzc2FnZXMiLCJnZXRBbGxGcm9tU3RvcmUiLCJmaWx0ZXIiLCJtc2ciLCJtYXAiLCJzb3J0IiwiYSIsImIiLCJ1cGRhdGVNZXNzYWdlIiwidXBkYXRlcyIsImdldEZyb21TdG9yZSIsImRlbGV0ZU1lc3NhZ2UiLCJkZWxldGVGcm9tU3RvcmUiLCJzYXZlRmlsZSIsImZpbGUiLCJnZXRGaWxlcyIsImZpbGVzIiwic2F2ZUV2ZW50IiwiZ2V0RXZlbnRzIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImV2ZW50cyIsImZpbHRlcmVkRXZlbnRzIiwiZ2V0VGltZSIsInNhdmVVc2VyIiwidXNlciIsImdldFVzZXIiLCJkZXRlY3RDb25mbGljdCIsImxvY2FsRGF0YSIsInNlcnZlckRhdGEiLCJsb2NhbFRpbWVzdGFtcCIsInVwZGF0ZWRBdCIsInNlcnZlclRpbWVzdGFtcCIsInJlc29sdmVDb25mbGljdCIsImNvbmZsaWN0SWQiLCJyZXNvbHV0aW9uIiwiY29uZmxpY3QiLCJyZXNvbHZlZERhdGEiLCJsb2NhbFZlcnNpb24iLCJzZXJ2ZXJWZXJzaW9uIiwibWVyZ2VEYXRhIiwibG9jYWwiLCJzZXJ2ZXIiLCJtZXJnZWQiLCJrZXkiLCJ1bmRlZmluZWQiLCJhY3Rpb24iLCJzeW5jSXRlbSIsInJldHJpZXMiLCJtYXhSZXRyaWVzIiwic3luY1F1ZXVlIiwicHVzaCIsInN5bmNJblByb2dyZXNzIiwicXVldWUiLCJpdGVtIiwiY29uc29sZSIsInVybCIsIm1ldGhvZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwiZ2V0QXV0aFRva2VuIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzdG9yZU5hbWUiLCJ0cmFuc2FjdGlvbiIsInN0b3JlIiwib2JqZWN0U3RvcmUiLCJwdXQiLCJnZXQiLCJnZXRBbGwiLCJkZWxldGUiLCJjbGVhckFsbERhdGEiLCJzdG9yZU5hbWVzIiwiY2xlYXIiLCJnZXRTdG9yYWdlSW5mbyIsImJ5VHlwZSIsInRvdGFsIiwiY291bnQiLCJnZXRTdG9yZUNvdW50IiwibmF2aWdhdG9yIiwib25MaW5lIiwib2ZmbGluZVN0b3JhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/offline-storage.ts\n"));

/***/ })

});